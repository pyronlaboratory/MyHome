package com.myhome.security.filters;

import com.myhome.domain.User;
import com.myhome.services.CommunityService;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.web.authentication.www.BasicAuthenticationFilter;

import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * TODO
 */
public class CommunityAuthorizationFilter extends BasicAuthenticationFilter {
  private final CommunityService communityService;
  private static final String UUID_PATTERN =
      "[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}";
  private static final Pattern ADD_AMENITY_REQUEST_PATTERN =
      Pattern.compile("/communities/" + UUID_PATTERN + "/amenities");

  public CommunityAuthorizationFilter(AuthenticationManager authenticationManager,
      CommunityService communityService) {
    super(authenticationManager);
    this.communityService = communityService;
  }

  /**
   * in the provided code is a filter that checks the request URI against a pattern and
   * performs an administrative check on the user. If the user is not an administrator,
   * it sets the status code to `SC_FORBIDDEN` and returns without further processing.
   * 
   * @param request HTTP request object that is being processed by the filter.
   * 
   * 	- `getRequestURI()` - This method returns the request URI (path) of the incoming
   * HTTP request.
   * 	- `isUserCommunityAdmin()` - This method checks if the user is an admin for a
   * specific community.
   * 	- `super.doFilterInternal()` - This method calls the superclass's `doFilterInternal`
   * method to handle the rest of the request processing.
   * 
   * @param response HTTP response object that is being filtered.
   * 
   * 	- `HttpServletResponse`: This is the response object that is passed as an argument
   * to the function. It contains information about the HTTP request and response, such
   * as the status code, headers, and buffered content.
   * 	- `status`: This is a property of the `HttpServletResponse` object that represents
   * the current status code of the response. In this particular case, it can take on
   * values from 100 to 599, indicating different types of responses, such as success,
   * redirection, or error.
   * 	- `headers`: This is another property of the `HttpServletResponse` object that
   * contains a collection of HTTP headers associated with the response. These headers
   * provide additional information about the response, such as caching directives,
   * content type, and expiration time.
   * 	- `bufferedContent`: This is a property of the `HttpServletResponse` object that
   * represents the buffered content of the response. In this context, it could contain
   * the deserialized input data that needs to be processed by the filter chain.
   * 
   * @param chain next filter in the filter chain that the current filter is processing.
   * 
   * 	- `HttpServletRequest request`: The current HTTP request received by the filter.
   * 	- `HttpServletResponse response`: The current HTTP response generated by the filter.
   * 	- `FilterChain chain`: The chain of filters that the current filter is part of,
   * which can be further processed or executed.
   * 	- `IOException IOException`: Thrown if any I/O-related errors occur during the
   * filtering process.
   * 	- `ServletException ServletException`: Thrown if any processing-related errors
   * occur during the filtering process.
   */
  @Override
  protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response,
      FilterChain chain) throws IOException, ServletException {

    Matcher urlMatcher = ADD_AMENITY_REQUEST_PATTERN.matcher(request.getRequestURI());

    if (urlMatcher.find() && !isUserCommunityAdmin(request)) {
      response.setStatus(HttpServletResponse.SC_FORBIDDEN);
      return;
    }

    super.doFilterInternal(request, response, chain);
  }

  /**
   * checks if a user is an admin of a community based on their principal ID and the
   * community ID in the request URL. It uses community service to find admins and then
   * filters and maps the IDs to check if the user is an admin.
   * 
   * @param request HTTP request received by the server, providing information about
   * the URL path and query parameters that can be used to identify the community being
   * accessed.
   * 
   * 	- `request.getRequestURI()`: Returns the requested URI path of the incoming HTTP
   * request. It splits into two parts: the scheme and authority (if present), followed
   * by the path and any fragments.
   * 	- `request.getAuthentication()`: Provides the authenticated principal, which is
   * usually a user object in a web application context.
   * 
   * @returns a boolean value indicating whether the current user is an admin of the
   * specified community.
   * 
   * 	- The function returns a boolean value indicating whether the current user is a
   * community admin for the specified community ID.
   * 	- The input parameters include the current request and the community ID.
   * 	- The function first retrieves the user ID of the authenticated principal using
   * SecurityContextHolder.
   * 	- Then, it queries the community service to find the admins of the community ID
   * and filters them based on the user ID.
   * 	- Finally, it checks if the user ID is present in the filtered list of admins
   * using the `flatMap` and `findFirst` methods.
   */
  private boolean isUserCommunityAdmin(HttpServletRequest request) {
    String userId = (String) SecurityContextHolder.getContext().getAuthentication().getPrincipal();
    String communityId = request.getRequestURI().split("/")[2];

    return communityService.findCommunityAdminsById(communityId, null)
        .flatMap(admins -> admins.stream()
            .map(User::getUserId)
            .filter(userId::equals)
            .findFirst()
        )
        .isPresent();
  }
}
