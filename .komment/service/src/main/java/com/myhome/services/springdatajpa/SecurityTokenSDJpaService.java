{"name":"SecurityTokenSDJpaService.java","path":"service/src/main/java/com/myhome/services/springdatajpa/SecurityTokenSDJpaService.java","content":{"structured":{"description":"A `SecurityTokenSDJpaService` class that implements `SecurityTokenService` and provides methods for creating and managing security tokens. The class uses Spring Data JPA and Lombok to interact with a database. The methods include:\n\n* `createEmailConfirmToken`: creates an email confirm token for a user\n* `createPasswordResetToken`: creates a password reset token for a user\n* `useToken`: marks a token as used in the database\n\nThe class also defines constants and variables for token expiration times.","image":"<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\"\n \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n<!-- Generated by graphviz version 2.43.0 (0)\n -->\n<!-- Title: com.myhome.domain.SecurityToken Pages: 1 -->\n<svg width=\"187pt\" height=\"148pt\"\n viewBox=\"0.00 0.00 187.00 148.00\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n<g id=\"graph0\" class=\"graph\" transform=\"scale(1 1) rotate(0) translate(4 144)\">\n<title>com.myhome.domain.SecurityToken</title>\n<!-- Node1 -->\n<g id=\"Node000001\" class=\"node\">\n<title>Node1</title>\n<g id=\"a_Node000001\"><a xlink:title=\" \">\n<polygon fill=\"#999999\" stroke=\"#666666\" points=\"173,-30 6,-30 6,0 173,0 173,-30\"/>\n<text text-anchor=\"start\" x=\"14\" y=\"-18\" font-family=\"Helvetica,sans-Serif\" font-size=\"10.00\">com.myhome.domain.Security</text>\n<text text-anchor=\"middle\" x=\"89.5\" y=\"-7\" font-family=\"Helvetica,sans-Serif\" font-size=\"10.00\">Token</text>\n</a>\n</g>\n</g>\n<!-- Node2 -->\n<g id=\"Node000002\" class=\"node\">\n<title>Node2</title>\n<g id=\"a_Node000002\"><a xlink:href=\"classcom_1_1myhome_1_1domain_1_1BaseEntity.html\" target=\"_top\" xlink:title=\" \">\n<polygon fill=\"white\" stroke=\"#666666\" points=\"179,-85 0,-85 0,-66 179,-66 179,-85\"/>\n<text text-anchor=\"middle\" x=\"89.5\" y=\"-73\" font-family=\"Helvetica,sans-Serif\" font-size=\"10.00\">com.myhome.domain.BaseEntity</text>\n</a>\n</g>\n</g>\n<!-- Node2&#45;&gt;Node1 -->\n<g id=\"edge1_Node000001_Node000002\" class=\"edge\">\n<title>Node2&#45;&gt;Node1</title>\n<g id=\"a_edge1_Node000001_Node000002\"><a xlink:title=\" \">\n<path fill=\"none\" stroke=\"#63b8ff\" d=\"M89.5,-55.65C89.5,-47.36 89.5,-37.78 89.5,-30.11\"/>\n<polygon fill=\"#63b8ff\" stroke=\"#63b8ff\" points=\"86,-55.87 89.5,-65.87 93,-55.87 86,-55.87\"/>\n</a>\n</g>\n</g>\n<!-- Node3 -->\n<g id=\"Node000003\" class=\"node\">\n<title>Node3</title>\n<g id=\"a_Node000003\"><a xlink:title=\" \">\n<polygon fill=\"white\" stroke=\"#666666\" points=\"126.5,-140 52.5,-140 52.5,-121 126.5,-121 126.5,-140\"/>\n<text text-anchor=\"middle\" x=\"89.5\" y=\"-128\" font-family=\"Helvetica,sans-Serif\" font-size=\"10.00\">Serializable</text>\n</a>\n</g>\n</g>\n<!-- Node3&#45;&gt;Node2 -->\n<g id=\"edge2_Node000002_Node000003\" class=\"edge\">\n<title>Node3&#45;&gt;Node2</title>\n<g id=\"a_edge2_Node000002_Node000003\"><a xlink:title=\" \">\n<path fill=\"none\" stroke=\"#63b8ff\" d=\"M89.5,-110.66C89.5,-101.93 89.5,-91.99 89.5,-85.09\"/>\n<polygon fill=\"#63b8ff\" stroke=\"#63b8ff\" points=\"86,-110.75 89.5,-120.75 93,-110.75 86,-110.75\"/>\n</a>\n</g>\n</g>\n</g>\n</svg>\n","items":[{"id":"3eeb4a7b-6595-b8b1-2e49-753a56a9ee0a","ancestors":[],"type":"function","description":"TODO","name":"SecurityTokenSDJpaService","code":"@Service\n@RequiredArgsConstructor\npublic class SecurityTokenSDJpaService implements SecurityTokenService {\n\n  private final SecurityTokenRepository securityTokenRepository;\n\n  @Value(\"${tokens.reset.expiration}\")\n  private Duration passResetTokenTime;\n  @Value(\"${tokens.email.expiration}\")\n  private Duration emailConfirmTokenTime;\n\n  private SecurityToken createSecurityToken(SecurityTokenType tokenType, Duration liveTimeSeconds, User tokenOwner) {\n    String token = UUID.randomUUID().toString();\n    LocalDate creationDate = LocalDate.now();\n    LocalDate expiryDate = getDateAfterDays(LocalDate.now(), liveTimeSeconds);\n    SecurityToken newSecurityToken = new SecurityToken(tokenType, token, creationDate, expiryDate, false, null);\n    newSecurityToken.setTokenOwner(tokenOwner);\n    newSecurityToken = securityTokenRepository.save(newSecurityToken);\n    return newSecurityToken;\n  }\n\n  @Override\n  public SecurityToken createEmailConfirmToken(User tokenOwner) {\n    return createSecurityToken(SecurityTokenType.EMAIL_CONFIRM, emailConfirmTokenTime, tokenOwner);\n  }\n\n  @Override\n  public SecurityToken createPasswordResetToken(User tokenOwner) {\n    return createSecurityToken(SecurityTokenType.RESET, passResetTokenTime, tokenOwner);\n  }\n\n  @Override\n  public SecurityToken useToken(SecurityToken token) {\n    token.setUsed(true);\n    token = securityTokenRepository.save(token);\n    return token;\n  }\n\n  private LocalDate getDateAfterDays(LocalDate date, Duration liveTime) {\n    return date.plusDays(liveTime.toDays());\n  }\n}","location":{"start":16,"insert":16,"offset":" ","indent":0},"item_type":"class","length":42},{"id":"b700b952-fd56-bea8-fd45-3e6caa8c33db","ancestors":["3eeb4a7b-6595-b8b1-2e49-753a56a9ee0a"],"type":"function","description":"creates a new security token based on input parameters and saves it to the repository, returning the newly created token.","params":[{"name":"tokenType","type_name":"SecurityTokenType","description":"type of security token being created, which determines the format and content of the token.\n\n* `tokenType`: This parameter represents the type of security token being created, which can be either `Active`, `Inactive`, or `Invalid`.\n* `liveTimeSeconds`: This parameter specifies the duration in seconds that the security token is valid for.\n* `tokenOwner`: This parameter represents the user who owns the security token.","complex_type":true},{"name":"liveTimeSeconds","type_name":"Duration","description":"duration of time that the generated security token will be valid, and is used to calculate the expiry date of the token.\n\n* `Duration liveTimeSeconds`: A `Duration` object representing the time period for which the security token is valid. It is a measure of time in seconds, and it can be positive or negative.\n* `LocalDate creationDate`: The date and time when the security token was created. It represents the moment when the security token was generated.\n* `LocalDate expiryDate`: The date and time when the security token will expire. It represents the moment when the security token will become invalid.\n* `boolean isActive`: A flag indicating whether the security token is currently active or not. If it is `true`, then the security token is valid and can be used; otherwise, it is `false`.\n* `SecurityTokenRepository securityTokenRepository`: An instance of a repository class that provides methods for storing and retrieving security tokens.","complex_type":true},{"name":"tokenOwner","type_name":"User","description":"user who owns the security token being created.\n\n* `tokenOwner`: The user who owns the security token.\n* `UUID.randomUUID().toString()`: Generates a unique UUID string for the token.","complex_type":true}],"returns":{"type_name":"SecurityToken","description":"a newly created security token instance with the specified details.\n\n1. `token`: A unique token string generated using the `UUID` class.\n2. `creationDate`: The current date and time when the token was created, represented as a `LocalDate`.\n3. `expiryDate`: The date and time after which the token will expire, calculated by subtracting the `liveTimeSeconds` from the current date and time, also represented as a `LocalDate`.\n4. `tokenOwner`: The user who owns the token, stored as an instance of the `User` class.\n5. `SecurityToken`: An instance of the `SecurityToken` class, which represents the token itself.\n\nNote that the `securityTokenRepository` is not explicitly mentioned in the output, as it is assumed to be a dependency of the function.","complex_type":true},"usage":{"language":"java","code":"//Create a password reset token for user \"john\"\nUser john = new User(\"john\", \"123456\");\nSecurityTokenType tokenType = SecurityTokenType.RESET;\nDuration liveTimeSeconds = Duration.ofDays(7); //This can be adjusted based on the requirements of your application\ncreateSecurityToken(tokenType, liveTimeSeconds, john);\n","description":""},"name":"createSecurityToken","code":"private SecurityToken createSecurityToken(SecurityTokenType tokenType, Duration liveTimeSeconds, User tokenOwner) {\n    String token = UUID.randomUUID().toString();\n    LocalDate creationDate = LocalDate.now();\n    LocalDate expiryDate = getDateAfterDays(LocalDate.now(), liveTimeSeconds);\n    SecurityToken newSecurityToken = new SecurityToken(tokenType, token, creationDate, expiryDate, false, null);\n    newSecurityToken.setTokenOwner(tokenOwner);\n    newSecurityToken = securityTokenRepository.save(newSecurityToken);\n    return newSecurityToken;\n  }","location":{"start":27,"insert":27,"offset":" ","indent":2},"item_type":"method","length":9},{"id":"15a1c949-1e87-44ad-d747-8e52dedcb058","ancestors":["3eeb4a7b-6595-b8b1-2e49-753a56a9ee0a"],"type":"function","description":"creates a security token for an user based on the type \"EMAIL_CONFIRM\" and time parameter.","params":[{"name":"tokenOwner","type_name":"User","description":"user whose email confirmation token is being generated.\n\n* `tokenOwner`: A `User` object representing the user for whom the email confirmation token is being created.\n* `emailConfirmTokenTime`: The time at which the email confirmation token is being created, in milliseconds since the epoch (January 1, 1970, 00:00:00 UTC).","complex_type":true}],"returns":{"type_name":"SecurityToken","description":"a security token of type `EMAIL_CONFIRM`.\n\nSecurityToken createEmailConfirm Token (type): This is the type of security token created, specifically EMAIL_CONFIRM.\n\nemailConfirmTokenTime: This indicates when the email confirmation token was generated or created.\n\ntokenOwner: The owner of the security token, which in this case is a User object.","complex_type":true},"usage":{"language":"java","code":"@Override\n  public SecurityToken createEmailConfirmToken(User tokenOwner) {\n    return createSecurityToken(SecurityTokenType.EMAIL_CONFIRM, emailConfirmTokenTime, tokenOwner);\n  }\n}\n","description":"\nThe method takes a user object as an input and returns a security token object that has the same user as its owner. The security token is then saved in the database with its type set to \"email confirmation\" and its expiration date calculated based on the duration provided in the emailConfirmTokenTime variable. The returned security token can be used to verify whether or not an email address has been confirmed by the user."},"name":"createEmailConfirmToken","code":"@Override\n  public SecurityToken createEmailConfirmToken(User tokenOwner) {\n    return createSecurityToken(SecurityTokenType.EMAIL_CONFIRM, emailConfirmTokenTime, tokenOwner);\n  }","location":{"start":37,"insert":37,"offset":" ","indent":2},"item_type":"method","length":4},{"id":"295255be-aa00-79ae-eb46-f1a256521e36","ancestors":["3eeb4a7b-6595-b8b1-2e49-753a56a9ee0a"],"type":"function","description":"creates a security token for resetting a user's password based on provided parameters and returns the generated token.","params":[{"name":"tokenOwner","type_name":"User","description":"user for whom the password reset token is being created.\n\n* `tokenOwner`: This parameter represents the user for whom the password reset token is being generated. It has an `username` attribute that contains the user's username.","complex_type":true}],"returns":{"type_name":"SecurityToken","description":"a SecurityToken object representing a password reset token.\n\n* `SecurityTokenType`: This variable represents the type of security token that is being created, specifically `RESET`.\n* `passResetTokenTime`: This variable contains the time when the password reset token was created.\n* `tokenOwner`: This variable references the user whose account is being reset with the token.","complex_type":true},"usage":{"language":"java","code":"User user = new User();\nuser.setEmail(\"johndoe@example.com\");\nSecurityToken token = securityTokenService.createPasswordResetToken(user);\n\n// do something with the token\n","description":""},"name":"createPasswordResetToken","code":"@Override\n  public SecurityToken createPasswordResetToken(User tokenOwner) {\n    return createSecurityToken(SecurityTokenType.RESET, passResetTokenTime, tokenOwner);\n  }","location":{"start":42,"insert":42,"offset":" ","indent":2},"item_type":"method","length":4},{"id":"787fe802-1487-a189-0242-af2cd12e9cc0","ancestors":["3eeb4a7b-6595-b8b1-2e49-753a56a9ee0a"],"type":"function","description":"updates and saves a SecurityToken object, marking it as used and storing it in the repository for later retrieval.","params":[{"name":"token","type_name":"SecurityToken","description":"SecurityToken that will be used and saved in the repository after being marked as used.\n\n1. `setUsed(true)`: This line marks the token as used, indicating that it has been successfully validated and is ready for use in further operations.\n2. `securityTokenRepository.save(token)`: This line saves the token to the security token repository, ensuring its persistence and availability for future references.","complex_type":true}],"returns":{"type_name":"SecurityToken","description":"a newly saved SecurityToken object with the used flag set to true and the original token object referenced.\n\n* `token`: This is the SecurityToken object that has been updated with the `setUsed(true)` method call and then saved in the security token repository using the `save()` method.\n* `setUsed(true)`: This sets the `used` attribute of the SecurityToken object to `true`, indicating that the token has been used.\n* `securityTokenRepository`: This is the repository where the SecurityToken object is saved after being updated and returned as part of the function output.","complex_type":true},"usage":{"language":"java","code":"SecurityToken securityToken = new SecurityToken(\"token\", SecurityTokenType.RESET);\nsecurityToken = service.useToken(securityToken);\nassertEquals(true, securityToken.getUsed());\n","description":""},"name":"useToken","code":"@Override\n  public SecurityToken useToken(SecurityToken token) {\n    token.setUsed(true);\n    token = securityTokenRepository.save(token);\n    return token;\n  }","location":{"start":47,"insert":47,"offset":" ","indent":2},"item_type":"method","length":6},{"id":"d9d551e9-6fa1-34af-274a-69070c487d90","ancestors":["3eeb4a7b-6595-b8b1-2e49-753a56a9ee0a"],"type":"function","description":"takes a `LocalDate` and a `Duration` as input, and returns the date that is `plusDays` later.","params":[{"name":"date","type_name":"LocalDate","description":"initial LocalDate to be adjusted by adding a specified number of days.\n\n* `LocalDate date`: This represents a date in the format of `YYYY-MM-DD`.\n* `liveTime Duration liveTime`: This represents a duration of time in milliseconds.\n\nThe function returns a new `LocalDate` object representing the date after adding the specified number of days to the original `date`.","complex_type":true},{"name":"liveTime","type_name":"Duration","description":"number of days to add to the `date` input parameter, resulting in the new date after the specified duration has passed.\n\n* `toDays()`: This method returns the duration in days.","complex_type":true}],"returns":{"type_name":"LocalDate","description":"a new LocalDate that represents the date after adding the specified number of days to the input date.\n\nThe returned value is a `LocalDate` object representing the date after the specified number of days from the original `date`.\n\nThe `plusDays` method is used to calculate the new date by adding the specified number of days to the original `date`.","complex_type":true},"usage":{"language":"java","code":"LocalDate date = LocalDate.now();\nDuration liveTime = Duration.ofDays(10);\nLocalDate updatedDate = getDateAfterDays(date, liveTime);\nSystem.out.println(\"Updated Date is \" + updatedDate); // prints 'Updated Date is 2023-06-04'\n","description":""},"name":"getDateAfterDays","code":"private LocalDate getDateAfterDays(LocalDate date, Duration liveTime) {\n    return date.plusDays(liveTime.toDays());\n  }","location":{"start":54,"insert":54,"offset":" ","indent":2},"item_type":"method","length":3}]}}}