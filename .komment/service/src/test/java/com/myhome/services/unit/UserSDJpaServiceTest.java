{"name":"UserSDJpaServiceTest.java","path":"service/src/test/java/com/myhome/services/unit/UserSDJpaServiceTest.java","content":{"structured":{"description":"","items":[{"id":"f8720938-59f0-40d3-99d9-c2c0e02c8cb1","ancestors":[],"type":"function","name":"setUp","location":{"offset":" ","indent":2,"insert":68,"start":68},"returns":false,"params":[],"code":"@BeforeEach\n  void setUp() {\n    MockitoAnnotations.initMocks(this);\n  }","skip":false,"length":4,"comment":{"description":"sets up Mockito annotations for the current test class, allowing for more effective and efficient testing.","params":[],"returns":null}},{"id":"bf6276ee-f6ba-45e5-a027-3b588c46b3aa","ancestors":[],"type":"function","name":"createUserSuccess","location":{"offset":" ","indent":2,"insert":73,"start":73},"returns":false,"params":[],"code":"@Test\n  void createUserSuccess() {\n    // given\n    UserDto request = getDefaultUserDtoRequest();\n    User resultUser = getUserFromDto(request);\n    UserDto response = UserDto.builder()\n        .id(resultUser.getId())\n        .userId(resultUser.getUserId())\n        .name(resultUser.getName())\n        .encryptedPassword(resultUser.getEncryptedPassword())\n        .communityIds(new HashSet<>())\n        .build();\n    SecurityToken emailConfirmToken =\n        getSecurityToken(SecurityTokenType.EMAIL_CONFIRM, \"token\", resultUser);\n\n    given(userRepository.findByEmail(request.getEmail()))\n        .willReturn(null);\n    given(passwordEncoder.encode(request.getPassword()))\n        .willReturn(request.getPassword());\n    given(userMapper.userDtoToUser(request))\n        .willReturn(resultUser);\n    given(userRepository.save(resultUser))\n        .willReturn(resultUser);\n    given(userMapper.userToUserDto(resultUser))\n        .willReturn(response);\n    given(securityTokenService.createEmailConfirmToken(resultUser))\n        .willReturn(emailConfirmToken);\n\n    // when\n    Optional<UserDto> createdUserDtoOptional = userService.createUser(request);\n\n    // then\n    assertTrue(createdUserDtoOptional.isPresent());\n    UserDto createdUserDto = createdUserDtoOptional.get();\n    assertEquals(response, createdUserDto);\n    assertEquals(0, createdUserDto.getCommunityIds().size());\n    verify(userRepository).findByEmail(request.getEmail());\n    verify(passwordEncoder).encode(request.getPassword());\n    verify(userRepository).save(resultUser);\n    verify(securityTokenService).createEmailConfirmToken(resultUser);\n  }","skip":false,"length":41,"comment":{"description":"tests the create user method by providing a valid user request, then verifying that the created user's details match the expected response and that the email confirmation token is generated.","params":[],"returns":null}},{"id":"20a7d32f-622b-44aa-85b8-f832b7808340","ancestors":[],"type":"function","name":"createUserEmailExists","location":{"offset":" ","indent":2,"insert":115,"start":115},"returns":false,"params":[],"code":"@Test\n  void createUserEmailExists() {\n    // given\n    UserDto request = getDefaultUserDtoRequest();\n    User user = getUserFromDto(request);\n\n    given(userRepository.findByEmail(request.getEmail()))\n        .willReturn(user);\n\n    // when\n    Optional<UserDto> createdUserDto = userService.createUser(request);\n\n    // then\n    assertFalse(createdUserDto.isPresent());\n    verify(userRepository).findByEmail(request.getEmail());\n  }","skip":false,"length":16,"comment":{"description":"tests whether creating a user with an email address that already exists in the database returns an empty Optional.","params":[],"returns":null}},{"id":"421f2d6e-caae-4b2c-8de7-76f6cd5dde01","ancestors":[],"type":"function","name":"getUserDetailsSuccess","location":{"offset":" ","indent":2,"insert":132,"start":132},"returns":false,"params":[],"code":"@Test\n  void getUserDetailsSuccess() {\n    // given\n    UserDto userDto = getDefaultUserDtoRequest();\n    User user = getUserFromDto(userDto);\n\n    given(userRepository.findByUserIdWithCommunities(USER_ID))\n        .willReturn(Optional.of(user));\n    given(userMapper.userToUserDto(user))\n        .willReturn(userDto);\n\n    // when\n    Optional<UserDto> createdUserDtoOptional = userService.getUserDetails(USER_ID);\n\n    // then\n    assertTrue(createdUserDtoOptional.isPresent());\n    UserDto createdUserDto = createdUserDtoOptional.get();\n    assertEquals(userDto, createdUserDto);\n    assertEquals(0, createdUserDto.getCommunityIds().size());\n    verify(userRepository).findByUserIdWithCommunities(USER_ID);\n  }","skip":false,"length":21,"comment":{"description":"verifies that the user details can be retrieved successfully using the provided ID, and maps the user from the repository to a DTO for further processing.","params":[],"returns":null}},{"id":"dd2be11f-71ff-471e-b7bf-a2744babd4ac","ancestors":[],"type":"function","name":"getUserDetailsSuccessWithCommunityIds","location":{"offset":" ","indent":2,"insert":154,"start":154},"returns":false,"params":[],"code":"@Test\n  void getUserDetailsSuccessWithCommunityIds() {\n    // given\n    UserDto userDto = getDefaultUserDtoRequest();\n    User user = new User(userDto.getName(), userDto.getUserId(), userDto.getEmail(), false,\n        userDto.getEncryptedPassword(), new HashSet<>(), null);\n\n    Community firstCommunity = TestUtils.CommunityHelpers.getTestCommunity(user);\n    Community secCommunity = TestUtils.CommunityHelpers.getTestCommunity(user);\n\n    Set<Community> communities =\n        Stream.of(firstCommunity, secCommunity).collect(Collectors.toSet());\n\n    Set<String> communitiesIds = communities\n        .stream()\n        .map(community -> community.getCommunityId())\n        .collect(Collectors.toSet());\n\n    given(userRepository.findByUserIdWithCommunities(USER_ID))\n        .willReturn(Optional.of(user));\n    given(userMapper.userToUserDto(user))\n        .willReturn(userDto);\n\n    // when\n    Optional<UserDto> createdUserDtoOptional = userService.getUserDetails(USER_ID);\n\n    // then\n    assertTrue(createdUserDtoOptional.isPresent());\n    UserDto createdUserDto = createdUserDtoOptional.get();\n    assertEquals(userDto, createdUserDto);\n    assertEquals(communitiesIds, createdUserDto.getCommunityIds());\n    verify(userRepository).findByUserIdWithCommunities(USER_ID);\n  }","skip":false,"length":33,"comment":{"description":"retrieves a user's details and their community IDs from the database, verifies the results and updates the user's details with the communities IDs.","params":[],"returns":null}},{"id":"5014b35b-6347-4e87-95c9-e2cbc6d8449a","ancestors":[],"type":"function","name":"getUserDetailsNotFound","location":{"offset":" ","indent":2,"insert":188,"start":188},"returns":false,"params":[],"code":"@Test\n  void getUserDetailsNotFound() {\n    // given\n    given(userRepository.findByUserIdWithCommunities(USER_ID))\n        .willReturn(Optional.empty());\n\n    // when\n    Optional<UserDto> createdUserDto = userService.getUserDetails(USER_ID);\n\n    // then\n    assertFalse(createdUserDto.isPresent());\n    verify(userRepository).findByUserIdWithCommunities(USER_ID);\n  }","skip":false,"length":13,"comment":{"description":"tests whether the `userService` method `getUserDetails` returns an empty optional when the user with the given ID cannot be found in the repository.","params":[],"returns":null}},{"id":"32ad2185-6050-4c95-9f3d-43a9b8196315","ancestors":[],"type":"function","name":"confirmEmail","location":{"offset":" ","indent":2,"insert":202,"start":202},"returns":false,"params":[],"code":"@Test\n  void confirmEmail() {\n    // given\n    User user = getDefaultUser();\n    SecurityToken testSecurityToken =\n        getSecurityToken(SecurityTokenType.EMAIL_CONFIRM, TOKEN_LIFETIME, PASSWORD_RESET_TOKEN,\n            user);\n    user.getUserTokens().add(testSecurityToken);\n    given(securityTokenService.useToken(testSecurityToken))\n        .willReturn(testSecurityToken);\n    given(userRepository.findByUserIdWithTokens(user.getUserId()))\n        .willReturn(Optional.of(user));\n    //    given(mailService.sendAccountConfirmed(user))\n    //        .willReturn(true);\n\n    // when\n    boolean emailConfirmed =\n        userService.confirmEmail(user.getUserId(), testSecurityToken.getToken());\n\n    // then\n    assertTrue(emailConfirmed);\n    assertTrue(user.isEmailConfirmed());\n    verify(securityTokenService).useToken(testSecurityToken);\n    verify(userRepository).save(user);\n    //    verify(mailService).sendAccountConfirmed(user);\n  }","skip":false,"length":26,"comment":{"description":"confirms an email address for a user by using a security token to reset the user's password and then marking the email as confirmed in the user's record.","params":[],"returns":null}},{"id":"feca2a5f-22c4-4536-aa3c-6bfec0e9d5cf","ancestors":[],"type":"function","name":"confirmEmailWrongToken","location":{"offset":" ","indent":2,"insert":229,"start":229},"returns":false,"params":[],"code":"@Test\n  void confirmEmailWrongToken() {\n    // given\n    User user = getDefaultUser();\n    SecurityToken testSecurityToken =\n        getSecurityToken(SecurityTokenType.EMAIL_CONFIRM, TOKEN_LIFETIME, PASSWORD_RESET_TOKEN,\n            user);\n    user.getUserTokens().add(testSecurityToken);\n    given(userRepository.findByUserIdWithTokens(user.getUserId()))\n        .willReturn(Optional.of(user));\n\n    // when\n    boolean emailConfirmed = userService.confirmEmail(user.getUserId(), \"wrong-token\");\n\n    // then\n    assertFalse(emailConfirmed);\n    assertFalse(user.isEmailConfirmed());\n    verify(userRepository, never()).save(user);\n    verifyNoInteractions(securityTokenService);\n    verifyNoInteractions(mailService);\n  }","skip":false,"length":21,"comment":{"description":"tests the user service's method `confirmEmail`, which checks if the provided token is valid for email confirmation and updates the user's email confirmation status accordingly. If the token is invalid, the function asserts that the method returns `false` and the user's email confirmation status remains unchanged.","params":[],"returns":null}},{"id":"0aa9a0e5-3d17-4638-a935-28710b8b2899","ancestors":[],"type":"function","name":"confirmEmailUsedToken","location":{"offset":" ","indent":2,"insert":251,"start":251},"returns":false,"params":[],"code":"@Test\n  void confirmEmailUsedToken() {\n    // given\n    User user = getDefaultUser();\n    SecurityToken testSecurityToken =\n        getSecurityToken(SecurityTokenType.EMAIL_CONFIRM, TOKEN_LIFETIME, PASSWORD_RESET_TOKEN,\n            user);\n    testSecurityToken.setUsed(true);\n    user.getUserTokens().add(testSecurityToken);\n    given(userRepository.findByUserIdWithTokens(user.getUserId()))\n        .willReturn(Optional.of(user));\n\n    // when\n    boolean emailConfirmed =\n        userService.confirmEmail(user.getUserId(), testSecurityToken.getToken());\n\n    // then\n    assertFalse(emailConfirmed);\n    assertFalse(user.isEmailConfirmed());\n    verify(userRepository, never()).save(user);\n    verifyNoInteractions(securityTokenService);\n    verifyNoInteractions(mailService);\n  }","skip":false,"length":23,"comment":{"description":"tests whether an email confirmation token is correctly confirmed for a user. It sets the used status of a security token to true, adds it to the user's tokens, and then calls the `confirmEmail` method with the token. The function asserts that the email is not confirmed and verifies that no interactions occurred with the repository or mail services.","params":[],"returns":null}},{"id":"acf3292c-0b32-4420-afd7-c207f5fb0cb8","ancestors":[],"type":"function","name":"confirmEmailNoToken","location":{"offset":" ","indent":2,"insert":275,"start":275},"returns":false,"params":[],"code":"@Test\n  void confirmEmailNoToken() {\n    // given\n    User user = getDefaultUser();\n    given(userRepository.findByUserIdWithTokens(user.getUserId()))\n        .willReturn(Optional.of(user));\n\n    // when\n    boolean emailConfirmed = userService.confirmEmail(user.getUserId(), \"any-token\");\n\n    // then\n    assertFalse(emailConfirmed);\n    assertFalse(user.isEmailConfirmed());\n    verify(userRepository, never()).save(user);\n    verifyNoInteractions(securityTokenService);\n    verifyNoInteractions(mailService);\n  }","skip":false,"length":17,"comment":{"description":"tests the confirmation of an email address without a token. It provides a default user, saves it to the repository, and then confirms the email using a fake token. The function verifies that the email is not confirmed and does not interact with any external services like security tokens or mail services.","params":[],"returns":null}},{"id":"a7d9286b-fb42-43c1-887f-b8f5f85efd16","ancestors":[],"type":"function","name":"confirmEmailAlreadyConfirmed","location":{"offset":" ","indent":2,"insert":293,"start":293},"returns":false,"params":[],"code":"@Test\n  void confirmEmailAlreadyConfirmed() {\n    // given\n    User user = getDefaultUser();\n    SecurityToken testSecurityToken =\n        getSecurityToken(SecurityTokenType.EMAIL_CONFIRM, TOKEN_LIFETIME, PASSWORD_RESET_TOKEN,\n            user);\n    user.getUserTokens().add(testSecurityToken);\n    user.setEmailConfirmed(true);\n    given(userRepository.findByUserIdWithTokens(user.getUserId()))\n        .willReturn(Optional.of(user));\n\n    // when\n    boolean emailConfirmed =\n        userService.confirmEmail(user.getUserId(), testSecurityToken.getToken());\n\n    // then\n    assertFalse(emailConfirmed);\n    verify(userRepository, never()).save(user);\n    verifyNoInteractions(securityTokenService);\n    verifyNoInteractions(mailService);\n  }","skip":false,"length":22,"comment":{"description":"verifies that an email address is already confirmed when given a security token for confirmation.","params":[],"returns":null}},{"id":"2c4d14e5-f951-495c-9826-0656b11a8522","ancestors":[],"type":"function","name":"findUserByEmailSuccess","location":{"offset":" ","indent":2,"insert":316,"start":316},"returns":false,"params":[],"code":"@Test\n  void findUserByEmailSuccess() {\n    // given\n    UserDto userDto = getDefaultUserDtoRequest();\n    User user = getUserFromDto(userDto);\n\n    given(userRepository.findByEmail(USER_EMAIL))\n        .willReturn(user);\n    given(userMapper.userToUserDto(user))\n        .willReturn(userDto);\n\n    // when\n    Optional<UserDto> resultUserDtoOptional = userService.findUserByEmail(USER_EMAIL);\n\n    // then\n    assertTrue(resultUserDtoOptional.isPresent());\n    UserDto createdUserDto = resultUserDtoOptional.get();\n    assertEquals(userDto, createdUserDto);\n    assertEquals(0, createdUserDto.getCommunityIds().size());\n    verify(userRepository).findByEmail(USER_EMAIL);\n  }","skip":false,"length":21,"comment":{"description":"tests the `findUserByEmail` method of a user service by providing an email and verifying that the correct user is returned from the repository after mapping to a DTO.","params":[],"returns":null}},{"id":"c4e448d6-71b3-4dd5-9b88-987dafaab45c","ancestors":[],"type":"function","name":"findUserByEmailSuccessWithCommunityIds","location":{"offset":" ","indent":2,"insert":338,"start":338},"returns":false,"params":[],"code":"@Test\n  void findUserByEmailSuccessWithCommunityIds() {\n    // given\n    UserDto userDto = getDefaultUserDtoRequest();\n    User user = getUserFromDto(userDto);\n\n    Community firstCommunity = TestUtils.CommunityHelpers.getTestCommunity(user);\n    Community secCommunity = TestUtils.CommunityHelpers.getTestCommunity(user);\n\n    Set<Community> communities =\n        Stream.of(firstCommunity, secCommunity).collect(Collectors.toSet());\n\n    Set<String> communitiesIds = communities\n        .stream()\n        .map(Community::getCommunityId)\n        .collect(Collectors.toSet());\n\n    given(userRepository.findByEmail(USER_EMAIL))\n        .willReturn(user);\n    given(userMapper.userToUserDto(user))\n        .willReturn(userDto);\n\n    // when\n    Optional<UserDto> resultUserDtoOptional = userService.findUserByEmail(USER_EMAIL);\n\n    // then\n    assertTrue(resultUserDtoOptional.isPresent());\n    UserDto createdUserDto = resultUserDtoOptional.get();\n    assertEquals(userDto, createdUserDto);\n    assertEquals(communitiesIds, createdUserDto.getCommunityIds());\n    verify(userRepository).findByEmail(USER_EMAIL);\n  }","skip":false,"length":32,"comment":{"description":"verifies that a user can be found by email and their community IDs are retrieved from the database and returned.","params":[],"returns":null}},{"id":"c16c6031-2a8a-4132-aa67-83574122bf1e","ancestors":[],"type":"function","name":"findUserByEmailNotFound","location":{"offset":" ","indent":2,"insert":371,"start":371},"returns":false,"params":[],"code":"@Test\n  void findUserByEmailNotFound() {\n    // given\n    given(userRepository.findByEmail(USER_EMAIL))\n        .willReturn(null);\n\n    // when\n    Optional<UserDto> resultUserDtoOptional = userService.findUserByEmail(USER_EMAIL);\n\n    // then\n    assertFalse(resultUserDtoOptional.isPresent());\n    verify(userRepository).findByEmail(USER_EMAIL);\n  }","skip":false,"length":13,"comment":{"description":"verifies that a user is not found by their email address in the repository, and returns an `Optional` object indicating the absence of a user.","params":[],"returns":null}},{"id":"eb4f03f2-87be-4c88-aaf9-d7708a9dab2a","ancestors":[],"type":"function","name":"requestResetPassword","location":{"offset":" ","indent":2,"insert":385,"start":385},"returns":false,"params":[],"code":"@Test\n  void requestResetPassword() {\n    // given\n    ForgotPasswordRequest forgotPasswordRequest = getForgotPasswordRequest();\n    User user = getDefaultUser();\n    SecurityToken testSecurityToken =\n        getSecurityToken(SecurityTokenType.RESET, TOKEN_LIFETIME, PASSWORD_RESET_TOKEN, null);\n    given(securityTokenService.createPasswordResetToken(user))\n        .willReturn(testSecurityToken);\n    given(userRepository.findByEmailWithTokens(forgotPasswordRequest.getEmail()))\n        .willReturn(Optional.of(user));\n    given(mailService.sendPasswordRecoverCode(user, testSecurityToken.getToken()))\n        .willReturn(true);\n\n    // when\n    boolean resetRequested = userService.requestResetPassword(forgotPasswordRequest);\n\n    // then\n    assertTrue(resetRequested);\n    assertEquals(getUserSecurityToken(user, SecurityTokenType.RESET), testSecurityToken);\n    verify(securityTokenService).createPasswordResetToken(user);\n    verify(userRepository).findByEmailWithTokens(forgotPasswordRequest.getEmail());\n    verify(userRepository).save(user);\n    verify(mailService).sendPasswordRecoverCode(user, testSecurityToken.getToken());\n  }","skip":false,"length":25,"comment":{"description":"in the code below allows a user to request a password reset link through email. It validates the request by checking if the user's email is associated with a security token and checks if the link has been sent successfully through mail service. If successful, it saves the updated user information and notifies the system that the reset request was made.","params":[],"returns":null}},{"id":"9c65b087-592a-4d73-ac8e-5cf33a9d6a23","ancestors":[],"type":"function","name":"requestResetPasswordUserNotExists","location":{"offset":" ","indent":2,"insert":411,"start":411},"returns":false,"params":[],"code":"@Test\n  void requestResetPasswordUserNotExists() {\n    // given\n    ForgotPasswordRequest forgotPasswordRequest = getForgotPasswordRequest();\n    User user = getDefaultUser();\n    SecurityToken testSecurityToken =\n        getSecurityToken(SecurityTokenType.RESET, TOKEN_LIFETIME, PASSWORD_RESET_TOKEN, user);\n    given(securityTokenService.createPasswordResetToken(user))\n        .willReturn(testSecurityToken);\n    given(userRepository.findByEmailWithTokens(forgotPasswordRequest.getEmail()))\n        .willReturn(Optional.empty());\n\n    // when\n    boolean resetRequested = userService.requestResetPassword(forgotPasswordRequest);\n\n    // then\n    assertFalse(resetRequested);\n    assertNotEquals(getUserSecurityToken(user, SecurityTokenType.RESET), testSecurityToken);\n    verifyNoInteractions(securityTokenService);\n    verify(userRepository).findByEmailWithTokens(forgotPasswordRequest.getEmail());\n    verify(userRepository, never()).save(user);\n    verifyNoInteractions(mailService);\n  }","skip":false,"length":23,"comment":{"description":"tests the user service's request for password reset when the user does not exist in the database. It verifies that the function returns false and a different security token than what is expected.","params":[],"returns":null}},{"id":"29f7e53a-154b-4e60-b841-ed7afc2c2ef3","ancestors":[],"type":"function","name":"resetPassword","location":{"offset":" ","indent":2,"insert":435,"start":435},"returns":false,"params":[],"code":"@Test\n  void resetPassword() {\n    // given\n    ForgotPasswordRequest forgotPasswordRequest = getForgotPasswordRequest();\n    User user = getDefaultUser();\n    SecurityToken testSecurityToken =\n        getSecurityToken(SecurityTokenType.RESET, TOKEN_LIFETIME, PASSWORD_RESET_TOKEN, user);\n    user.getUserTokens().add(testSecurityToken);\n    given(userRepository.findByEmailWithTokens(forgotPasswordRequest.getEmail()))\n        .willReturn(Optional.of(user));\n    given(passwordEncoder.encode(forgotPasswordRequest.getNewPassword()))\n        .willReturn(forgotPasswordRequest.getNewPassword());\n    when(userRepository.save(user))\n        .then(returnsFirstArg());\n    given(mailService.sendPasswordSuccessfullyChanged(user))\n        .willReturn(true);\n    given(securityTokenService.useToken(testSecurityToken))\n        .willReturn(testSecurityToken);\n\n    // when\n    boolean passwordChanged = userService.resetPassword(forgotPasswordRequest);\n\n    // then\n    assertTrue(passwordChanged);\n    assertEquals(user.getEncryptedPassword(), forgotPasswordRequest.getNewPassword());\n    verify(userRepository).findByEmailWithTokens(forgotPasswordRequest.getEmail());\n    verify(passwordEncoder).encode(forgotPasswordRequest.getNewPassword());\n    verify(mailService).sendPasswordSuccessfullyChanged(user);\n    verify(securityTokenService).useToken(testSecurityToken);\n  }","skip":false,"length":30,"comment":{"description":"resets a user's password by generating a new security token, saving it to the database, sending an email to the user with a link to reset their password, and updating the user's encrypted password in the database.","params":[],"returns":null}},{"id":"9e6a2a72-085d-4f5b-b150-5843c2dc8ead","ancestors":[],"type":"function","name":"resetPasswordUserNotExists","location":{"offset":" ","indent":2,"insert":466,"start":466},"returns":false,"params":[],"code":"@Test\n  void resetPasswordUserNotExists() {\n    // given\n    ForgotPasswordRequest forgotPasswordRequest = getForgotPasswordRequest();\n    User user = getDefaultUser();\n    SecurityToken testSecurityToken =\n        getSecurityToken(SecurityTokenType.RESET, TOKEN_LIFETIME, PASSWORD_RESET_TOKEN, user);\n    user.getUserTokens().add(testSecurityToken);\n    ;\n    given(userRepository.findByEmailWithTokens(forgotPasswordRequest.getEmail()))\n        .willReturn(Optional.empty());\n\n    // when\n    boolean passwordChanged = userService.resetPassword(forgotPasswordRequest);\n\n    // then\n    assertFalse(passwordChanged);\n    assertNotEquals(user.getEncryptedPassword(), forgotPasswordRequest.getNewPassword());\n    verify(userRepository).findByEmailWithTokens(forgotPasswordRequest.getEmail());\n    verifyNoInteractions(securityTokenRepository);\n    verifyNoInteractions(passwordEncoder);\n    verifyNoInteractions(mailService);\n  }","skip":false,"length":23,"comment":{"description":"tests the user service's `resetPassword` method when the user does not exist in the repository. It verifies that the method returns `false`, and the new password is not equal to the original password. Additionally, it checks for interactions with the repository, token encoder, mail service, and password encoder.","params":[],"returns":null}},{"id":"c62b3614-c8db-44e4-8b7a-1eb5be9bd641","ancestors":[],"type":"function","name":"resetPasswordTokenExpired","location":{"offset":" ","indent":2,"insert":490,"start":490},"returns":false,"params":[],"code":"@Test\n  void resetPasswordTokenExpired() {\n    // given\n    ForgotPasswordRequest forgotPasswordRequest = getForgotPasswordRequest();\n    SecurityToken testSecurityToken = getExpiredTestToken();\n    User user = getDefaultUser();\n    user.getUserTokens().add(testSecurityToken);\n    ;\n    given(userRepository.findByEmailWithTokens(forgotPasswordRequest.getEmail()))\n        .willReturn(Optional.of(user));\n\n    // when\n    boolean passwordChanged = userService.resetPassword(forgotPasswordRequest);\n\n    // then\n    assertFalse(passwordChanged);\n    assertNotEquals(user.getEncryptedPassword(), forgotPasswordRequest.getNewPassword());\n    assertFalse(getUserSecurityToken(user, SecurityTokenType.RESET).isUsed());\n    verify(userRepository).findByEmailWithTokens(forgotPasswordRequest.getEmail());\n    verifyNoInteractions(securityTokenRepository);\n    verifyNoInteractions(passwordEncoder);\n    verifyNoInteractions(mailService);\n  }","skip":false,"length":23,"comment":{"description":"tests the method `resetPassword` for when the provided security token has expired. It verifies that the password is not changed, and the security token is not marked as used after calling the method.","params":[],"returns":null}},{"id":"8229700c-3703-4579-89a5-52dc5db6c314","ancestors":[],"type":"function","name":"resetPasswordTokenNotExists","location":{"offset":" ","indent":2,"insert":514,"start":514},"returns":false,"params":[],"code":"@Test\n  void resetPasswordTokenNotExists() {\n    // given\n    ForgotPasswordRequest forgotPasswordRequest = getForgotPasswordRequest();\n    User user = getDefaultUser();\n    given(userRepository.findByEmailWithTokens(forgotPasswordRequest.getEmail()))\n        .willReturn(Optional.of(user));\n\n    // when\n    boolean passwordChanged = userService.resetPassword(forgotPasswordRequest);\n\n    // then\n    assertFalse(passwordChanged);\n    assertNotEquals(user.getEncryptedPassword(), forgotPasswordRequest.getNewPassword());\n    verify(userRepository).findByEmailWithTokens(forgotPasswordRequest.getEmail());\n    verifyNoInteractions(securityTokenRepository);\n    verifyNoInteractions(passwordEncoder);\n    verifyNoInteractions(mailService);\n  }","skip":false,"length":19,"comment":{"description":"tests the User Service's method `resetPassword()` when a token for the specified email does not exist in the database.","params":[],"returns":null}},{"id":"32c510ac-55af-42be-ac9e-305e3316f14f","ancestors":[],"type":"function","name":"resetPasswordTokenNotMatches","location":{"offset":" ","indent":2,"insert":534,"start":534},"returns":false,"params":[],"code":"@Test\n  void resetPasswordTokenNotMatches() {\n    // given\n    ForgotPasswordRequest forgotPasswordRequest = getForgotPasswordRequest();\n    SecurityToken testSecurityToken =\n        getSecurityToken(SecurityTokenType.RESET, TOKEN_LIFETIME, PASSWORD_RESET_TOKEN, null);\n    testSecurityToken.setToken(\"wrong-token\");\n    User user = getDefaultUser();\n    user.getUserTokens().add(testSecurityToken);\n    ;\n    given(userRepository.findByEmailWithTokens(forgotPasswordRequest.getEmail()))\n        .willReturn(Optional.of(user));\n\n    // when\n    boolean passwordChanged = userService.resetPassword(forgotPasswordRequest);\n\n    // then\n    assertFalse(passwordChanged);\n    assertNotEquals(user.getEncryptedPassword(), forgotPasswordRequest.getNewPassword());\n    assertNotNull(getUserSecurityToken(user, SecurityTokenType.RESET));\n    verify(userRepository).findByEmailWithTokens(forgotPasswordRequest.getEmail());\n    verifyNoInteractions(securityTokenRepository);\n    verifyNoInteractions(passwordEncoder);\n    verifyNoInteractions(mailService);\n  }","skip":false,"length":25,"comment":{"description":"tests the error handling when the reset password token does not match the one stored in the database for the given user. It verifies that the password is not changed, the token is not null, and all dependencies are not interacted with.","params":[],"returns":null}},{"id":"f7d927e8-c622-44fb-8d7c-7152dc03c2af","ancestors":[],"type":"function","name":"getDefaultUserDtoRequest","location":{"offset":" ","indent":2,"insert":560,"start":560},"returns":"UserDto","params":[],"code":"private UserDto getDefaultUserDtoRequest() {\n    return UserDto.builder()\n        .userId(USER_ID)\n        .name(USERNAME)\n        .email(USER_EMAIL)\n        .encryptedPassword(USER_PASSWORD)\n        .communityIds(new HashSet<>())\n        .build();\n  }","skip":false,"length":9,"comment":{"description":"generates a pre-populated `UserDto` object with default values for user ID, name, email, encrypted password, and community IDs.","params":[],"returns":{"type":"UserDto","description":"a fully-populated `UserDto` instance representing a default user."}}},{"id":"f9da4c93-b86b-461c-9107-1c3f519a6369","ancestors":[],"type":"function","name":"getUserFromDto","location":{"offset":" ","indent":2,"insert":570,"start":570},"returns":"User","params":[{"name":"request","type":"UserDto"}],"code":"private User getUserFromDto(UserDto request) {\n    return new User(\n        request.getName(),\n        request.getUserId(),\n        request.getEmail(),\n        false,\n        request.getEncryptedPassword(),\n        new HashSet<>(),\n        new HashSet<>()\n    );\n  }","skip":false,"length":11,"comment":{"description":"takes a `UserDto` object as input and returns a `User` object with user details and encrypted password.","params":[{"name":"request","type":"UserDto","description":"`UserDto` object that contains the user details to be instantiated into a `User` object."}],"returns":{"type":"User","description":"a `User` object containing the provided Dto fields."}}},{"id":"f4c0a86c-7b35-4c78-9c81-2fa41d2376e5","ancestors":[],"type":"function","name":"getUserSecurityToken","location":{"offset":" ","indent":2,"insert":582,"start":582},"returns":"SecurityToken","params":[{"name":"user","type":"User"},{"name":"tokenType","type":"SecurityTokenType"}],"code":"private SecurityToken getUserSecurityToken(User user, SecurityTokenType tokenType) {\n    return user.getUserTokens()\n        .stream()\n        .filter(token -> token.getTokenType() == tokenType)\n        .findFirst()\n        .orElse(null);\n  }","skip":false,"length":7,"comment":{"description":"retrieves a user's security token based on the specified token type, filtering and finding the matching token from the user's tokens stream.","params":[{"name":"user","type":"User","description":"User object whose user tokens are to be searched for a matching token of the specified `tokenType`."},{"name":"tokenType","type":"SecurityTokenType","description":"type of security token that the function is searching for in the user's tokens stream."}],"returns":{"type":"SecurityToken","description":"a `SecurityToken` object representing the user's security token of the specified type, or `null` if no such token exists."}}},{"id":"a11f05ee-1a2f-4767-aae3-8baa2bb1e05a","ancestors":[],"type":"function","name":"getDefaultUser","location":{"offset":" ","indent":2,"insert":590,"start":590},"returns":"User","params":[],"code":"private User getDefaultUser() {\n    return getUserFromDto(getDefaultUserDtoRequest());\n  }","skip":false,"length":3,"comment":{"description":"retrieves a default user from a provided request.","params":[],"returns":{"type":"User","description":"a `User` object representing the default user for the application."}}},{"id":"d5dc7769-3887-48cf-a818-950baa96daaa","ancestors":[],"type":"function","name":"getForgotPasswordRequest","location":{"offset":" ","indent":2,"insert":594,"start":594},"returns":"ForgotPasswordRequest","params":[],"code":"private ForgotPasswordRequest getForgotPasswordRequest() {\n    ForgotPasswordRequest request = new ForgotPasswordRequest();\n    request.setEmail(USER_EMAIL);\n    request.setNewPassword(NEW_USER_PASSWORD);\n    request.setToken(PASSWORD_RESET_TOKEN);\n    return request;\n  }","skip":false,"length":7,"comment":{"description":"creates a new `ForgotPasswordRequest` object with email, new password, and token properties set to specific values.","params":[],"returns":{"type":"ForgotPasswordRequest","description":"a ForgotPasswordRequest object containing email, new password, and token."}}},{"id":"6fd9887a-8be1-444e-aed0-3774fc141ec4","ancestors":[],"type":"function","name":"getExpiredTestToken","location":{"offset":" ","indent":2,"insert":602,"start":602},"returns":"SecurityToken","params":[],"code":"private SecurityToken getExpiredTestToken() {\n    return new SecurityToken(SecurityTokenType.RESET, PASSWORD_RESET_TOKEN, LocalDate.now(),\n        LocalDate.now().minusDays(TOKEN_LIFETIME.toDays()), false, null);\n  }","skip":false,"length":4,"comment":{"description":"generates a test security token with an expiration date that is equal to the current date minus a specified number of days, and sets the token's lifespan to false.","params":[],"returns":{"type":"SecurityToken","description":"a security token with an expiration date in the future."}}},{"id":"4095c117-4abd-48ec-bf4f-d93dabe7294b","ancestors":[],"type":"function","name":"getSecurityToken","location":{"offset":" ","indent":2,"insert":607,"start":607},"returns":"SecurityToken","params":[{"name":"tokenType","type":"SecurityTokenType"},{"name":"lifetime","type":"Duration"},{"name":"token","type":"String"},{"name":"user","type":"User"}],"code":"private SecurityToken getSecurityToken(SecurityTokenType tokenType, Duration lifetime,\n      String token, User user) {\n    LocalDate expireDate = LocalDate.now().plusDays(lifetime.toDays());\n    return new SecurityToken(tokenType, token, LocalDate.now(), expireDate, false, user);\n  }","skip":false,"length":5,"comment":{"description":"generates a new security token with the specified type, token, and lifetime. The token is set to expire on the current date plus the specified number of days.","params":[{"name":"tokenType","type":"SecurityTokenType","description":"type of security token being generated, which determines the format and content of the token."},{"name":"lifetime","type":"Duration","description":"duration of time that the generated security token is valid for."},{"name":"token","type":"String","description":"128-bit security token value that is generated and returned by the `getSecurityToken()` method."},{"name":"user","type":"User","description":"user for whom the security token is being generated."}],"returns":{"type":"SecurityToken","description":"a newly generated security token instance with specified properties."}}},{"id":"6ae50d6e-09fc-43c5-a4b9-b04c169ae220","ancestors":[],"type":"function","name":"getSecurityToken","location":{"offset":" ","indent":2,"insert":613,"start":613},"returns":"SecurityToken","params":[{"name":"tokenType","type":"SecurityTokenType"},{"name":"token","type":"String"},{"name":"user","type":"User"}],"code":"private SecurityToken getSecurityToken(SecurityTokenType tokenType, String token, User user) {\n    LocalDate expireDate = LocalDate.now().plusDays(Duration.ofDays(1).toDays());\n    return new SecurityToken(tokenType, token, LocalDate.now(), expireDate, false, user);\n  }","skip":false,"length":4,"comment":{"description":"generates a new security token with specified type, token, and user, and sets an expiration date and boolean flag to indicate if it's invalid or not.","params":[{"name":"tokenType","type":"SecurityTokenType","description":"type of security token being generated, which determines the format and content of the token."},{"name":"token","type":"String","description":"16-digit security token number for the specified type of security token."},{"name":"user","type":"User","description":"user who is requesting the security token."}],"returns":{"type":"SecurityToken","description":"a `SecurityToken` object containing the specified details."}}}]}}}